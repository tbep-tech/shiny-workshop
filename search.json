[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dashboards: Using R to create actionable science",
    "section": "",
    "text": "About this Workshop\nThe Shiny R package is now ten years old and is a popular tool to create immersive, web-based content. Although many coastal scientists have experience with R, expertise in dashboards is uncommon. This workshop will include a mix of instructor-led demonstrations, discussion, and exercises that will empower attendees to create their own Shiny applications. We will begin by showing what’s possible with the Quarto publishing system and Shiny by demoing existing applications from the Marine Biodiversity Observation Network (MarineBON.org) and the National Estuary Program (epa.gov/NEP). We will then transition to instructional material on the fundamentals of reactive programming with Shiny. Recent additions and improvements to Shiny (e.g., drag and drop user interface development, Python integration) will also be demonstrated. The remainder of the workshop will involve hands-on exercises that will allow attendees to develop their own applications using data from the examples above.\nAnyone interested in learning how to expand existing R skills for dashboard development will benefit from this workshop. This includes student, early career, and advanced professionals from any employment sector and field of expertise.\nAlso see:"
  },
  {
    "objectID": "index.html#agenda",
    "href": "index.html#agenda",
    "title": "Dashboards: Using R to create actionable science",
    "section": "Agenda",
    "text": "Agenda\n\n\n\n\n\nTime\nTopic\n\n\n\n\n9:00\nIntroduction\n\n\n9:15\nDynamic: Quarto\n\n\n10:30\nbreak\n\n\n10:45\nDynamic: Quarto (cont)\n\n\n11:45\nPublish Quarto reports\n\n\n12:00\nlunch\n\n\n12:30\nInteractive: Shiny\n\n\n3:00\nbreak\n\n\n3:15\nPublish Shiny apps\n\n\n4:00\nCo-designing\n\n\n5:00\nadjourn"
  },
  {
    "objectID": "index.html#important-links",
    "href": "index.html#important-links",
    "title": "Dashboards: Using R to create actionable science",
    "section": "Important links",
    "text": "Important links\n\nWorkshop Website: https://tbep-tech.github.io/shiny-workshop\nLive Chat: https://app.gitter.im/#/room/#shiny-workshop:gitter.im\nPosit Cloud: https://posit.cloud/content/5544370"
  },
  {
    "objectID": "index.html#setup",
    "href": "index.html#setup",
    "title": "Dashboards: Using R to create actionable science",
    "section": "Setup",
    "text": "Setup\nPlease visit the setup page for instructions on preparing for this workshop. You will be required to install R, RStudio, and Quarto prior to the workshop. You will also need to setup a GitHub and shinyapps.io account.\nWe also expect some prior experience using R. Please visit the intro to R page for a quick crash course."
  },
  {
    "objectID": "index.html#presenters",
    "href": "index.html#presenters",
    "title": "Dashboards: Using R to create actionable science",
    "section": "Presenters",
    "text": "Presenters\n\nMarcus Beck, Ph.D.\n\n\n\n\n\n\n\n\nMarcus Beck is the Program Scientist for the Tampa Bay Estuary Program in St. Petersburg, Florida and is developing data analysis and visualization methods for Bay health indicators. Marcus has experience researching environmental indicators and developing open science products to support environmental decision-making. He has been using the R statistical programming language for over 15 years and has taught several workshops on its application to environmental sciences. Marcus has also developed several R packages and currently maintains 7 on CRAN. He received a PhD in Conservation Biology with a minor in Statistics from the University of Minnesota in 2013, his Masters in Conservation Biology from the University of Minnesota in 2009, and his Bachelors in Zoology from the University of Florida in 2007.\n\n\n\n\nBen Best, Ph.D.\n\n\n\n\n\n\n\n\nBen Best is an environmental data scientist at his consultancy EcoQuants LLC working predominantly on marine spatial ecology, particularly marine biodiversity and environmentally responsible marine renewable energy development. He taught courses at graduate and undergraduate levels as well as workshops on reproducible research, environmental informatics, spatial analysis, landscape ecology, machine learning and collaborative coding. He has worked on big data marine biogeographic and conservation projects such as OBIS-SEAMAP, Ocean Health Index, Marine Biodiversity Observation Network (MBON), NOAA’s Integrated Ecosystem Assessment, California Cooperative Fisheries Investigation (CalCOFI) and WhaleSafe. He has a PhD from Duke University’s Marine Geospatial Ecology Lab, a Masters in Environmental Sciences from Duke and undergraduate degrees in Aquatic Biology and Geography from UC Santa Barbara.\n\n\n\n\nEnrique Montes, Ph.D.\n\n\n\n\n\n\n\n\nEnrique Montes is a biological oceanographer working at the U. Miami Cooperative Institute for Marine and Atmospheric Studies (CIMAS) and NOAA’s Atlantic Oceanographic and Meteorological Laboratory (AOML) studying responses of marine life to changes in atmospheric and oceanographic conditions. His research integrates environmental, bio-optical, genomic, and taxonomic measurements collected from ships with satellite data to resolve the oceanographic context of local observations, and characterize regional biogeographic conditions and ocean habitats. He is a Co-Investigator of the Marine Biodiversity Observation Network (MBON) in the USA and internationally. Montes is the Principal Investigator of the MBON Pole-to-Pole of the Americas, presides the International Association for Biological Oceanography (IABO), and serves as Executive Committee member of the Scientific Committee on Oceanic Research (SCOR).\n\n\n\n\nTylar Murray, Ph.D.\n\n\n\n\n\n\n\n\nTylar Murray is an interdisciplinary PhD with a passion for data visualization, data analysis, pragmatic software engineering, FOSS, and science! Tylar is an advocate of hacker ethic, unix philosophy, AGI superiority, and optimistic futurism. Tylar has software engineering experience spanning the gamut of programming languages, and academic proficiency expanding the interface between the digital and physical worlds. Tylar is an experienced instructor of applied technologies under projects funded by NSF, NASA, Microsoft, Google, and others. Over the last 5 years, Tylar consistently ranks within the top 10% of contributors in terms of both GitHub commit metrics and Stack Overflow reputation ranks, signifying a lasting commitment to open development principles."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "2 Dynamic and Interactive applications\nThis workshop will expose you to the basics of creating interactive dashboards in R. Before we begin, it’s useful to distinguish between dynamic and interactive dashboards.\nFirst, dynamic applications can have the look and feel of an interactive Shiny dashboard, but are fundamentally different. They are standalone and do not include a server component. Any interactive functionality is pre-built into the application and they are built before being hosted on a web platform as an HTML file. Applications such as Quarto (and its predecessor RMarkdown) can be used to create dynamic applications. Here’s an example.\nBy comparison, a Shiny application is fully interactive - it has both a user interface (UI) and server allowing a user to send requests to the server through the UI. This allows reactivity of the application components, where the content that a user sees on the UI is controlled by their inputs in a fully interactive experience. These applications require combined or separate R scripts that define the UI and server components. Here’s an example.\nThis workshop will cover both dynamic and interactive applications. Your needs for creating an application will determine which approach you use. In general, more complexity will require an interactive approach, but the rapidly evolving toolbox has greatly expanded the capabilities of dynamic applications. You may find that you can build a simpler dynamic application without having to integrate interactive Shiny components. Here’s an example.\nThroughout this workshop, we’ll cover the fundamentals of web-based applications in R for actionable science. We’ll first talk about Quarto dynamic applications in Chapter 2 and then dive into Shiny interactive applications in Chapter 3. We’ll also discuss often overlooked but important concepts of the user experience when developing and engaging with a web application in Chapter 4. Throughout, we’ll highlight real applications that demonstrate how these operate in the wild for their intended uses, many of which are highlighted on our resources page."
  },
  {
    "objectID": "intro.html#reactivity",
    "href": "intro.html#reactivity",
    "title": "1  Introduction",
    "section": "2.1 Reactivity",
    "text": "2.1 Reactivity\nFor dynamic applications, there’s not much you need to understand about coding beyond what you might already now about R. Creating the interactive components generally follows a familiar format. However, creating interactive applications in Shiny requires a fundamental shift in how you think about coding. It’s all done in R, but the pieces interact differently. You’re used to an R script from running top to bottom - code for a Shiny app runs up, down, and sideways depending on how you structure the components.\nA Shiny app runs from an R script, but instead of executing code linearly, it uses reactive programming that detects when an input is changed on the application, runs the minimal amount of code that uses that input, then updates the output as needed. So, rather than thinking of the script as linear, think of it as having interconnected components that share pieces of information to produce the results.\nThis can be daunting at first because it requires you to think about which pieces of your code require inputs from other pieces and how that information is used to create output. Reactivity creates the building blocks of a Shiny app. Every Shiny app has the following:\n\nUser interface (UI): Includes all inputs and outputs, as well as the appearance of the dashboard. Here, when we say “output” we mean the final product (e.g. a plot, table, etc.) that is placed on the ui, but created by processing inputs sent to the server. In web-speak, this is the front end.\nServer: The guts or engine of how the inputs are used to create the outputs, this is where the working parts of your analysis live. It can be as simple or as complicated as you like. In web-speak, this is the back end.\n\nAt it’s core, a Shiny app is an R script that contains The ui and server components. In practice, it looks like this:\n\nlibrary(shiny)\nui &lt;- fluidPage()\nserver &lt;- function(input, output){}\nshinyApp(ui = ui, server = server)\n\nYou “launch” or run the dashboard by sourcing the script or hitting the green “Run App” button on the top right.\n\n\n\n\n\nIf you run this code, you’ll see a local web browser pop up. It will be empty because this app does nothing, but this is only a starting point. All we need to do is populate the ui and server objects with code to do some things."
  },
  {
    "objectID": "intro.html#a-simple-example",
    "href": "intro.html#a-simple-example",
    "title": "1  Introduction",
    "section": "2.2 A simple example",
    "text": "2.2 A simple example\nNow let’s make our simple example do something. As with most problems, it’s good to start with identifying where you want to go and then work backwards to figure out how to get there. Let’s end with a simple histogram to visualize some data for the normal distribution, but with different sample sizes.\n\ndat &lt;- rnorm(100)\nhist(dat)\n\n\n\n\n\n\n\n\nChanging the sample size:\n\ndat &lt;- rnorm(10)\nhist(dat)\n\n\n\n\n\n\n\n\nTo make a Shiny app out of this, we need to identify our inputs and our outputs. The input in this case is what we want to be able to modify (the sample size) and the output is the plot. Inputs/outputs go in the ui object. The server takes the inputs, does something with them, then sends the results back to the ui. Putting this into our template would look something like this:\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  numericInput(inputId = 'n', label = 'Sample size', value = 50),\n  plotOutput('myplot')\n)\n\nserver &lt;- function(input, output){\n  output$myplot &lt;- renderPlot({\n    dat &lt;- rnorm(input$n)\n    hist(dat)\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\nOkay, so what is happening under the hood when you change the sample size?\n\nThe input value n (you name it) from the ui is sent to the server, seen as input$n.\nThe dat object is created as a random sample with size n and then a histogram is created as reactive output with renderPlot\nThe plot output named myplot (you name it) is appended to the output list of objects\nThe plot is then rendered on the ui side using plotOutput by referencing the myplot name from the output object.\n\n\n\n\n\n\nAll of this happens each time the input values are changed, such that the output reacts to any change in the input. This is a fundamental principle of Shiny functionality, simplified as follows."
  },
  {
    "objectID": "quarto.html#learning-objectives",
    "href": "quarto.html#learning-objectives",
    "title": "2  Dynamic: Quarto docs",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nUse the Quarto document preparation system to create interactive documents that combine text and code. Learn how to share these documents with colleagues through GitHub."
  },
  {
    "objectID": "quarto.html#install-quarto",
    "href": "quarto.html#install-quarto",
    "title": "2  Dynamic: Quarto docs",
    "section": "2.1 Install quarto",
    "text": "2.1 Install quarto\nEnsure you have the quarto R package installed. Look in RStudio’s Packages pane and Install if not found when searching for “quarto”.\nAdditionally, you can install the Quarto Command Line Interface (CLI). This will allow you to run Quarto from the command line and includes additional features not included with the R package. See the quarto setup section for more info."
  },
  {
    "objectID": "quarto.html#quarto-overview",
    "href": "quarto.html#quarto-overview",
    "title": "2  Dynamic: Quarto docs",
    "section": "2.2 Quarto overview",
    "text": "2.2 Quarto overview\nQuarto is a relatively new document preparation system that lets you create reproducible and dynamic content that is easily shared with others. Quarto is integrated with RStudio and allows you to combine plain text language with analysis code in the same document.\nQuarto belongs to a class of literate programming tools called dynamic documents (Knuth 1984). It is not the first of its kind, but it builds substantially on its predecessors by bridging multiple programming langues.\nAdvantages of creating analyses using Quarto include:\n\nClear demonstration of a workflow using plain text and code\nReproducible materials allow others to use your work\nEasily shared content (e.g., on GitHub)\nKeeping the data, analysis, and writing all in the same place\n\nThis next section will run through the very basics of creating a Quarto document, some of the options for formatting, and how to generate shared content. You’ll follow along in this module.\n\nCreate a new project in RStudio, first open RStudio and select “New project” from the File menu at the top.\n\n\n\n\n\nThen select “New Directory”. Create a directory in a location that’s easy to find.\n\n\n\n\n\nOpen a new Quarto file from the File menu under New file &gt; Quarto Document.\n\n\n\n\n\nEnter a title for the document (e.g., “Quarto practice”) and your name as the author. Use the defaults for the other options and hit “Create”.\n\n\n\n\n\nSave the file in the project root directory (give it any name you want).\nLet’s get familiar with the components of a Quarto document.\n\n\n\n\n\n\nTip\n\n\n\nThe three main components of a Quarto document are:\n\nYAML\nCode chunks\nPlain or Markdown text\n\n\n\nThe new file includes some template material showing the main components of a Quarto document. The content at the top is called YAML, which defines global options for the document.\n---\ntitle: \"Quarto practice\"\nauthor: \"Marcus Beck\"\neditor: visual\n---\nYou’ll also notice that there’s a button on the top-left that lets you toggle between “source” or “visual” editor mode. The source editor simply lets you add text to the document, whereas the visual editor lets you add content that is partially rendered. First time Quarto users may prefer the visual editor.\n\n\n\n\n\nUsing the visual editor, we can insert a code chunk (or code cell). This can be done by selecting the appropriate option from the Insert menu. Note the variety of programming langues that can be used with the code chunk.\n\n\n\n\n\nWe can enter any code we want in the code chunks, including options for how the code chunk is evaluated. Options are specified using the hashpipe notation, #|.\n```{r}\n#| echo: true\nprint('Hello Quarto!')\n```\nWhen the file is rendered, the code is run and results displayed in the output. There are many options to change how code chunks are executed, which we’ll discuss below.\n\nprint('Hello Quarto!')\n\n[1] \"Hello Quarto!\"\n\n\nWe can also run the code chunks separately without rendering the file using the arrow buttons on the top right in the source document. This can be useful for quickly evaluating your code as you include it in the file.\n\n\n\n\n\n\nTip\n\n\n\nCode chunks are executed in the order they appear in the document when a .qmd file is rendered.\n\n\nDescriptive text can be entered anywhere else in the file. This is where we can describe in plain language what our analysis does or any other relevant information. Text can be entered as-is or using simple markdown text that can format the appearance of the output. If you’re using the visual editor, you can use some of the items in the file menu to modify the text appearance. In the source editor, you can manually enter markdown text:\n\n\nI  can write anything I want right here. Here's some **bold text**.\n\nI can also make lists\n\n1. Item 1\n1. Item 2\n\n\n\nWhen the file is rendered, the markdown text will be formatted. The text will already be formatted if you’re using the visual editor:\n\nI can write anything I want right here. Here’s some bold text.\nI can also make lists\n\nItem 1\nItem 2\n\n\nRender the .qmd file to the output format.\nThe source file is a .qmd document. We need to render the document to create the output format - HTML (default), PDF, or Word. The following happens when you hit the render button at the top.\n\n\n\n\n\nHere’s what your RStudio session should look like (note the three parts of the source .qmd document - YAML, code chunk, and Markdown text). The rendered HTML file will appear in the Viewer pane on the right.\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nA rendered Quarto document as an HTML, PDF, Word, or other file format is stand-alone and can be shared with anybody!\n\n\n\n\n\n\n\n\n\n Exercise\n\n\n\nRepeat the above steps to create an RStudio project and Quarto file.\n\nCreate an RStudio project (skip is using Posit Cloud)\nOpen a new Quarto file\nCreate a code chunk and add some R code\nAdd some Markdown text outside of the code chunk\nRender your document to marvel at your work\n\n\n\n\n\n\n\n Answers\n\n\n\n\n\nThis is an example of what your Quarto file might look like:\n---\ntitle: \"Quarto practice\"\nauthor: \"Marcus Beck\"\neditor: visual\n---\n\nI  can write anything I want right here. Here's some **bold text**.\n    \nI can also make lists\n    \n1. Item 1\n1. Item 2\n    \n```{r}\n#| echo: true\nprint('Hello Quarto!')\n```"
  },
  {
    "objectID": "quarto.html#code-chunk-options",
    "href": "quarto.html#code-chunk-options",
    "title": "2  Dynamic: Quarto docs",
    "section": "2.3 Code chunk options",
    "text": "2.3 Code chunk options\nThe behavior of the code chunks when the file is rendered can be changed using the many options available in Quarto. This can be useful for a few reasons.\n\nOnly displaying the output of a code chunk\nOnly displaying the code and not running the chunk\nRunning the code without displaying output for use in other parts of the document\nSuppressing warnings and messages\nDefining table or figure options (e.g., height, width, captions, etc.)\n\nCode chunk options can be applied globally to all chunks in the document or separately for each chunk.\nTo apply them globally, they’ll look something like this in the YAML, where options are added after execute:\n---\ntitle: \"My Document\"\n\nexecute: \n  echo: false\n  warning: false\n---\n\n\n\n\n\n\nTip\n\n\n\nBe careful with indentation in the YAML, the document won’t render if the indentation is incorrect.\n\n\nTo apply to individual code chunks, use the #| (hashpipe) notation at the top of the code chunk. This will override any global options if you’ve included them in the top YAML. Below, echo: true indicates that the code will be displayed in the rendered output.\n```{r}\n#| echo: true\nplot(1:10)\n```\nHere’s a short list of other useful execution options:\n\n\n\n\n\n\n\nOption\nDescription\n\n\n\n\neval\nEvaluate the code chunk (if false, just echos the code into the output).\n\n\necho\nInclude the source code in output\n\n\noutput\nInclude the results of executing the code in the output (true, false, or asis to indicate that the output is raw markdown and should not have any of Quarto’s standard enclosing markdown).\n\n\nwarning\nInclude warnings in the output.\n\n\nerror\nInclude errors in the output (note that this implies that errors executing code will not halt processing of the document).\n\n\ninclude\nCatch all for preventing any output (code or results) from being included (e.g. include: false suppresses all output from the code block).\n\n\nmessage\nInclude messages in rendered output\n\n\n\nR code can also be executed “inline” outside of code chunks. This can be useful if you want to include statements that reference particular values or information that is linked directly to data. Inline R code is entered using the r syntax.\n\n\nI can enter inline text like `r 1 + 1`.\n\n\n\nText with inline R code will look like this when the document is rendered.\n\nI can enter inline text like 2."
  },
  {
    "objectID": "quarto.html#figures-and-tables",
    "href": "quarto.html#figures-and-tables",
    "title": "2  Dynamic: Quarto docs",
    "section": "2.4 Figures and tables",
    "text": "2.4 Figures and tables\nFigures and tables are easily added in Quarto, using either R code or importing from an external source.\nAny figures created in code chunks will be included in the rendered output. Relevant code chunk options for figures include fig-height, fig-width, fig-cap, label (for cross-referencing) and fig-align.\n```{r}\n#| label: fig-myhist\n#| fig-height: 4\n#| fig-width: 6\n#| fig-cap: \"Here's my awesome histogram.\"\n#| fig-align: \"center\"\nvals &lt;- rnorm(100)\nhist(vals)\n```\n\nvals &lt;- rnorm(100)\nhist(vals)\n\n\n\n\nFigure 2.1: Here’s my awesome histogram.\n\n\n\n\nFigures can be cross-referenced in the text using the @ notation with the figure label.\nHere's a cross-reference to @fig-myhist.\nWhen the file is rendered, the appropriate figure number will be displayed with a link to the figure:\n\nHere’s a cross-reference to Figure 2.1.\n\nSimilarly, tabular output can be created inside code chunks.\n```{r}\n#| label: tbl-mytable\n#| tbl-cap: \"Here's my awesome table.\"\ntotab &lt;- data.frame(\n  Species = c('Oysters', 'Seagrass', 'Sand'),\n  Count = c(12, 5, 4)\n)\nknitr::kable(totab)\n```\n\ntotab &lt;- data.frame(\n  Species = c('Oysters', 'Seagrass', 'Sand'),\n  Count = c(12, 5, 4)\n)\nknitr::kable(totab)\n\n\n\nTable 2.1: Here’s my awesome table.\n\n\nSpecies\nCount\n\n\n\n\nOysters\n12\n\n\nSeagrass\n5\n\n\nSand\n4\n\n\n\n\n\n\nAnd a cross-reference:\nHere's a cross-reference to @tbl-mytable.\n\nHere’s a cross-reference to Table 2.1.\n\n\n\n\n\n\n\nTip\n\n\n\nLabel tags for tables and figures should include the tbl- or fig- prefix for proper cross-referencing.\n\n\nFigures can also be imported from an external source (e.g., from your computer or the web) using the ![]() notation, where the image is in the img folder in my working directory. You can also simply add a figure from the file menu using the Visual editor.\n![](figs/quarto/oysters.jpg)\n\n\n\n\n\nYou can also add a figure from a URL using the same notation.\n![](https://unsplash.com/photos/HH-MuVCKal0)\n\n\n\n\n\nAdding captions and labels to external figures looks something like this:\n![Here are some beautiful oysters.](figs/quarto/oysters.jpg){#fig-oysters}\n\n\n\nFigure 2.2: Here are some beautiful oysters.\n\n\nThe cross-reference is done the same.\nHere's a cross-reference to @fig-oysters\n\nHere’s a cross-reference to Figure 2.2.\n\nLikewise, tables can be imported from an external source (e.g., Excel). You’ll want to do this in a code chunk and add the appropriate options (e.g., to cross-reference Table 2.2).\n```{r}\n#| label: tbl-habitats\n#| tbl-cap: \"The first six rows of our tidy data\"\nmytab &lt;- readxl::read_excel('data/tidy.xlsx')[1:6, ]\nknitr::kable(mytab)\n```\n\nmytab &lt;- readxl::read_excel('data/tidy.xlsx')[1:6, ]\nknitr::kable(mytab)\n\n\n\nTable 2.2: The first six rows of our tidy data\n\n\nLocation\nHabitat\nYear\nAcres\nCategory\n\n\n\n\nClear Bay\nSeagrass\n2019\n519\nB\n\n\nClear Bay\nOysters\n2019\n390\nB\n\n\nClear Bay\nSand\n2019\n742\nC\n\n\nFish Bay\nSeagrass\n2019\n930\nB\n\n\nFish Bay\nOysters\n2019\n680\nA\n\n\nFish Bay\nSand\n2019\n611\nA\n\n\n\n\n\n\nVisit these links for full details on figures and tables in Quarto. R also has a rich library of packages for producing tables, most of which play nice with Quarto.\n\n\n\n\n\n\n Exercise\n\n\n\nCreate some tables, figures, and cross-references as above.\n\nIn the same file from the first exercise, create a code chunk and add some R code to create a simple plot (e.g., hist(mtcars$mpg))\nGive the code chunk a label and figure caption\nUse the figure label to add a cross-reference outside of the code chunk\nRepeat the above, but this time create a table (e.g., knitr::kable(mtcars))\nRender your document to marvel at your work\n\n\n\n\n\n\n\n Answers\n\n\n\n\n\nThis is an example of what your Quarto file might look like:\n---\ntitle: \"Quarto practice\"\nauthor: \"Marcus Beck\"\neditor: visual\n---\n\nI  can write anything I want right here. Here's some **bold text**.\n    \nI can also make lists\n    \n1. Item 1\n1. Item 2\n    \n```{r}\n#| echo: true\nprint('Hello Quarto!')\n```\n\n@fig-myhist shows an awesome histogram. \n\n```{r}\n#| label: fig-myhist\n#| fig-cap: \"Here's my awesome histogram.\"\nhist(mtcars$mpg)\n```\n\n@tbl-mytable shows an awesome table. \n\n```{r}\n#| label: tbl-mytable\n#| tbl-cap: \"Here's my awesome table.\"\nknitr::kable(mtcars)\n```"
  },
  {
    "objectID": "quarto.html#quarto-using-htmlwidgets",
    "href": "quarto.html#quarto-using-htmlwidgets",
    "title": "2  Dynamic: Quarto docs",
    "section": "2.5 Quarto using htmlwidgets",
    "text": "2.5 Quarto using htmlwidgets\nThe htmlwidgets package allows you to embed dynamic components directly into a Quarto HTML page. There are several packages that use htmlwidgets to embed the required JavaScript visualization libraries. This does not require any knowledge of JavaScript, nor use of a Shiny Server.\n\n2.5.1 leaflet\nThe leaflet package can be used to create interactive maps (also see mapview) for an “out-of-the-box” option). Here’s a quick map of where we are - click on the marker to view the popup.\n\nlibrary(leaflet)\n\nleaflet() %&gt;%\n  addTiles() %&gt;%  # Add default OpenStreetMap map tiles\n  addMarkers(lng = -122.663, lat = 45.529, popup = \"CERF 2023 conference\")\n\n\n\n\n\n\n\n2.5.2 plotly and dygraphs\nThe plotly and dygraphs packages allow you to create interactive plots. They provide similar functionality, but serve different purposes.\n\nlibrary(plotly)\nlibrary(tibble)\n\n# data to plot\ntoplo &lt;- tibble(\n  Species = c('Oysters', 'Seagrass', 'Sand'),\n  `Clear Bay` = c(12, 5, 4), \n  `Fish Bay` = c(6, 7, 9)\n)\n\n# make a plotly plot\nfig &lt;- plot_ly(toplo, x = ~Species, y = ~`Clear Bay`, type = 'bar', name = 'Clear Bay')\nfig &lt;- fig %&gt;% add_trace(y = ~`Fish Bay`, name = 'Fish Bay')\nfig &lt;- fig %&gt;% layout(yaxis = list(title = 'Count'), barmode = 'group')\n\nfig\n\n\n\n\n\nThe plotly package has an additional feature that can easily transform existing ggplot objects into plotly objects using the ggplotly() function. This works fairly well for simple plots, although it is usually a better option to build plotly plots from scratch.\n\nlibrary(ggplot2)\nlibrary(tidyr)\n\n# data to plot\ntoplo &lt;- tibble(\n    Species = c('Oysters', 'Seagrass', 'Sand'),\n    `Clear Bay` = c(12, 5, 4), \n    `Fish Bay` = c(6, 7, 9)\n  ) %&gt;% \n  pivot_longer(-Species, names_to = 'Bay', values_to = 'Count')\n\n# make a ggplot\nfig &lt;- ggplot(toplo, aes(x = Species, y = Count, fill = Bay)) + \n  geom_bar(stat = 'identity', position = 'dodge')\n\n# conver to plotly\nggplotly(fig)\n\n\n\n\n\nPlotly also works well for three-dimensional plotting. Here we show a bathymetric map of Tampa Bay. The input file is a raster object converted to a matrix (see here)\n\nlibrary(plotly)\n\n# file created from a DEM, see \nload(file = 'data/demmat.RData')\n\nplot_ly(z = ~demmat) %&gt;% \n  add_surface(colorbar = list(title = 'Depth (m)')) \n\n\n\n\n\nWe can change some of the options using the layout() function. The aspect ratio, grid lines, and axis labels are all changed by created a list() object to pass to layout(). The color is changed in the add_surface() function (options here).\n\n# setup plot options\naxopt &lt;- list(showgrid = F, title = '', \n              zerolinecolor='rgb(255, 255, 255)', \n              tickvals = NA)\nscene &lt;- list(\n  aspectmode = 'manual', \n  aspectratio = list(x = 0.7, y = 1, z = 0.1),\n  xaxis = axopt, yaxis = axopt, zaxis = axopt\n  )\n\n# create plot\nplot_ly(z = ~demmat) %&gt;% \n  add_surface(colorbar = list(title = 'Depth (m)'), colorscale = 'Jet', \n              reversescale = T) %&gt;% \n  layout(scene = scene)\n\n\n\n\n\nThe dygraphs package is designed for time series data. First, we create a time series with random data, then plot it with dygraphs with a range selector.\n\nlibrary(dygraphs)\n\n# create data\nn &lt;- 1000\ny &lt;- cumsum(rnorm(n))\ndts &lt;- seq.Date(Sys.Date(), by = 'day', length.out = n)\ntoplo &lt;- tibble(\n  Date = dts, \n  y = y\n)\n\ndygraph(toplo) %&gt;% \n  dyRangeSelector()\n\n\n\n\n\n\n\n\n\n\n\n Exercise\n\n\n\nAdd some htmlwidgets to your Quarto document.\n\nCreate a code chunk and add some code to produce a leaflet map. You can use the same lat/lon coordinates from above or pick your own from Google Maps. Install the leaflet package if you need to.\nCreate another code chunk and add some code to create a dygraph object. You can use the same code from above or create your own time series. Install the dygraphs package if you need to.\nRender your document to marvel at your work\n\n\n\n\n\n\n\n Answers\n\n\n\n\n\nThis is an example of what your Quarto file might look like:\n---\ntitle: \"Quarto practice\"\nauthor: \"Marcus Beck\"\neditor: visual\n---\n\n```{r}\n#| echo: false\n#| message: false\nlibrary(leaflet)\nlibrary(dygraphs)\nlibrary(tibble)\n```\n\nI  can write anything I want right here. Here's some **bold text**.\n    \nI can also make lists\n    \n1. Item 1\n1. Item 2\n    \n```{r}\n#| echo: true\nprint('Hello Quarto!')\n```\n\n@fig-myhist shows an awesome histogram. \n\n```{r}\n#| label: fig-myhist\n#| fig-cap: \"Here's my awesome histogram.\"\nhist(mtcars$mpg)\n```\n\n@tbl-mytable shows an awesome table. \n\n```{r}\n#| label: tbl-mytable\n#| tbl-cap: \"Here's my awesome table.\"\nknitr::kable(mtcars)\n```\n\n```{r}\nleaflet() %&gt;% \n  addTiles() %&gt;% \n  addMarkers(lng = -82.5, lat = 27.5)\n```\n\n```{r}\n# create data\nn &lt;- 1000\ny &lt;- cumsum(rnorm(n))\ndts &lt;- seq.Date(Sys.Date(), by = 'day', length.out = n)\ntoplo &lt;- tibble(\n  Date = dts, \n  y = y\n)\n\ndygraph(toplo) %&gt;% \n  dyRangeSelector()\n```"
  },
  {
    "objectID": "quarto.html#quarto-using-crosstalk",
    "href": "quarto.html#quarto-using-crosstalk",
    "title": "2  Dynamic: Quarto docs",
    "section": "2.6 Quarto using crosstalk",
    "text": "2.6 Quarto using crosstalk\nThe crosstalk package can incorporate additional dynamic functionality in a Quarto document. As the name implies, it allows linking between plots and tables by including embedded Javascript in the rendered HTML file. This allows functionality that looks interactive as in a Shiny application, but does not require Shiny Server.\n\nlibrary(crosstalk)\nlibrary(leaflet)\nlibrary(DT)\nlibrary(dplyr)\n\n# import water quality data\ntbwqdat &lt;- read.csv('https://github.com/tbep-tech/shiny-workshop/raw/main/data/tbwqdat.csv') %&gt;% \n  filter(mo == 7)\n\n# create shared data\nsd &lt;- SharedData$new(tbwqdat)\n\n# create a filter input\nfilter_slider(\"chla\", \"Chlorophyll-a\", sd, column=~chla, step=0.1, width=250)\n\n# use shared data with crosstalk widgets\nbscols(\n  leaflet(sd) %&gt;% \n    addTiles() %&gt;% \n    addMarkers(),\n  datatable(\n    sd, extensions = \"Scroller\", style=\"bootstrap\", class = \"compact\", width = \"100%\", rownames = F,\n    options =list(\n      scrollY = 300, scroller = TRUE, \n      columnDefs = list(\n        list(visible = F, targets = c(0:1, 4)),\n         list(className = 'dt-left', targets = '_all'))\n      ),\n      colnames = c('lat', 'lon', 'Bay segment', 'Station', 'mo', 'Chl-a (ug/L)')\n    )\n  )\n\n\n\n\nChlorophyll-a"
  },
  {
    "objectID": "quarto.html#quarto-using-observable",
    "href": "quarto.html#quarto-using-observable",
    "title": "2  Dynamic: Quarto docs",
    "section": "2.7 Quarto using Observable",
    "text": "2.7 Quarto using Observable\nObservable is a relatively new approach that also allows dynamic features to be included in a Quarto document. It is an entirely separate language outside of R that uses JavaScript and allows excellent functionality similar what is provided by a Shiny Server. The following plot shows a histogram of chlorophyll values by bay segment that is created using the code below.\n\ndatatr = transpose(data)\nfiltered = datatr.filter(function(dat) {\n  return chla &lt; dat.chla &&\n    bay_segment.includes(dat.bay_segment) ;\n})\nviewof chla = Inputs.range(\n  [1.3, 66.6], \n  {value: 1.3, step: 1, label: \"Chlorophyll-a (ug/L):\"}\n)\nviewof bay_segment = Inputs.checkbox(\n  [\"OTB\", \"HB\", \"MTB\", \"LTB\"], \n  { value: [\"OTB\", \"HB\", \"MTB\", \"LTB\"], \n    label: \"Bay segments:\"\n  }\n)\nPlot.rectY(filtered, \n  Plot.binX(\n    {y: \"count\"}, \n    {x: \"chla\", thresholds: 10, fill: \"bay_segment\"}\n  ))\n  .plot({\n    x: {label: \"Chlorophyll-a\"},\n    color: {legend: true},\n    marks: [\n      Plot.frame(),\n    ]\n  }\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst, import the data as you would in R, then define variables for Observable using ojs_define(). Note that Observable code chunks cannot be run interactively and only work when an entire Quarto document is rendered.\n\n# import water quality data\ntbwqdat &lt;- readr::read_csv('https://github.com/tbep-tech/shiny-workshop/raw/main/data/tbwqdat.csv')\n\n# define variables\nojs_define(data = tbwqdat)\n\nThen we create some selector widgets to filter by the range of chlorophyll values and data by individual bay segments.\n```{ojs}\nviewof chla = Inputs.range(\n  [1.8, 17.4], \n  {value: 1.8, step: 1, label: \"Chlorophyll-a (ug/L):\"}\n)\nviewof bay_segment = Inputs.checkbox(\n  [\"OTB\", \"HB\", \"MTB\", \"LTB\"], \n  { value: [\"OTB\", \"HB\", \"MTB\", \"LTB\"], \n    label: \"Bay segments:\"\n  }\n)\n```\nA filtering function is then created to filter the data based on the selections from the widget. Note use of the transpose() function. This is required to use R data in a row/column format to an array format used in a JavaScript setting.\n```{ojs}\ndatatr = transpose(data)\nfiltered = datatr.filter(function(dat) {\n  return chla &lt; dat.chla &&\n    bay_segment.includes(dat.bay_segment) ;\n})\n```\nFinally, we create the plot using the filtered data function.\n```{ojs}\nPlot.rectY(filtered, \n  Plot.binX(\n    {y: \"count\"}, \n    {x: \"chla\", thresholds: 10, fill: \"bay_segment\"}\n  ))\n  .plot({\n    x: {label: \"Chlorophyll-a\"},\n    color: {legend: true},\n    marks: [\n      Plot.frame(),\n    ]\n  }\n)\n```\nAdditional information on using Observable with Quarto is available here"
  },
  {
    "objectID": "quarto.html#sharing-html-files",
    "href": "quarto.html#sharing-html-files",
    "title": "2  Dynamic: Quarto docs",
    "section": "2.8 Sharing HTML files",
    "text": "2.8 Sharing HTML files\nAn advantage of creating a dynamic HTML file with Quarto is the ability to share it with anybody. An HTML file can easily be shared by email, although it must be created as a “standalone” file for others to use. You’ll notice that sometimes external files or subfolders are created when you use any of the above options to add dynamic content. This is fine if you are working locally, but to share with others, you can create a standalone HTML file by adding the following option in the YAML:\nformat:\n  html:\n    embed-resources: true"
  },
  {
    "objectID": "quarto.html#publishing",
    "href": "quarto.html#publishing",
    "title": "2  Dynamic: Quarto docs",
    "section": "2.9 Publishing",
    "text": "2.9 Publishing\nA rendered HTML file can also be hosted online and shared by URL. This approach is useful to make the document available to anyone with the web address.\nThe easiest way to do this is to publish your document to RPubs, a free service from Posit for sharing web documents. Click the  publish button on the top-right of the editor toolbar. You will be prompted to create an account if you don’t have one already.\nThis can also be done using the quarto R package in the console.\nquarto::quarto_publish_doc(\n  \"data/quartoex.qmd\", \n  server = \"rpubs.com\"\n  )\nYou can also use the Quarto CLI in the terminal. Here we are publishing the document to Quarto Pub.\n\n\nTerminal\n\nquarto publish quarto-pub data/quartoex.qmd\n\nIf your Quarto document is in an RStudio project on GitHub, you can also publish to GitHub Pages.\n\n\nTerminal\n\nquarto publish gh-pages data/quartoex.qmd\n\n\n\n\n\n\n\n Exercise\n\n\n\nPublish your Quarto document using any of the methods above (bonus points if you use GitHub)."
  },
  {
    "objectID": "quarto.html#summary",
    "href": "quarto.html#summary",
    "title": "2  Dynamic: Quarto docs",
    "section": "2.10 Summary",
    "text": "2.10 Summary\nIn this module we learned the basics of creating dynamic documents with Quarto that combine markdown text with R code. There’s much, much more Quarto can do for you. Please visit https://quarto.org/ for more information on how you can use these documents to fully leverage their potential for open science.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "shiny.html#learning-objectives",
    "href": "shiny.html#learning-objectives",
    "title": "3  Interactive: Shiny apps",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nUse the Shiny framework to develop online interactive applications accepting user input to render outputs from arbitrary R functions. Server requirements differentiating from simpler Rmarkdown renderings will be reviewed."
  },
  {
    "objectID": "shiny.html#install-shiny-and-other-r-packages",
    "href": "shiny.html#install-shiny-and-other-r-packages",
    "title": "3  Interactive: Shiny apps",
    "section": "3.1 Install shiny and other R packages",
    "text": "3.1 Install shiny and other R packages\nEnsure you have the librarian R package installed. Look in RStudio’s Packages pane and Install if not found when searching for “librarian”. This allows us to use the helper function librarian::shelf() to load the libraries and install if needed:\n\nlibrarian::shelf(\n  dplyr, ggplot2, leaflet, plotly, \n  tbep-tech/tbeptools,\n  shiny, shinydashboard, tidyr)\n\nNote that the tbeptools R package is installed from source on Github given the ‘owner/repository’ naming convention, so tbep-tech/tbeptools has source code at github.com/tbep-tech/tbeptools.\nLater we’ll use the simpler base function library() to load the libraries in the Shiny app since when publishing to ShinyApps.io dependent libraries are automatically installed based on using library() (and not librarian::shelf()).\nIf you did not already have the shiny package installed, you should restart RStudio to use additional menu items for the next step."
  },
  {
    "objectID": "shiny.html#create-your-first-shiny-app",
    "href": "shiny.html#create-your-first-shiny-app",
    "title": "3  Interactive: Shiny apps",
    "section": "3.2 Create your first Shiny app",
    "text": "3.2 Create your first Shiny app\nLet’s create a simple Shiny app starting with the provided default in RStudio by going to the menu File -&gt; New File -&gt; Shiny Web App… and name it app-faithful (after faithful, the Old Faithful geyser eruption frequency dataset used in this default example):\n\n\n\n\n\nFor now, let’s go with the default Single File option that puts the entire application in app.R rather than splitting it in two (ui.R/server.R). You should see the following contents in the new file app.R:\n\n\nShow Code: app.R\n#\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    http://shiny.rstudio.com/\n#\n\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n\n    # Application title\n    titlePanel(\"Old Faithful Geyser Data\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"bins\",\n                        \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n           plotOutput(\"distPlot\")\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n\n    output$distPlot &lt;- renderPlot({\n        # generate bins based on input$bins from ui.R\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n        # draw the histogram with the specified number of bins\n        hist(x, breaks = bins, col = 'darkgray', border = 'white')\n    })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n\n\n3.2.1 Run App\nLet’s next Run App. Note that you can change the options by clicking on the down triangle next to the button, such as running the app in your default web browser (Run External), a pop-up window or in RStudio’s Viewer Pane.\n\n\n\n\n\nThis is equivalent to sourcing the app.R file in the R console, including the last line which launches the application after defining the user interface (ui) and server functions (server):\nshinyApp(ui, server)\nNow you can change the values in the slider on the left to change the “Number of bins” (input$bins) and see the updated plot (output$distPlot):\n\n\n\n\n\nIn Shiny parlance, the histogram plot is reactive to the slider (see Reactivity). Normally when creating web apps, this type of “reactivity” is quite complicated to code, but here by simply using input$bins in the plotting function for the output$distPlot, Shiny registers that this plot needs to be updated when the user changes the input$bins value.\n\n\n3.2.2 Run in showcase mode\nThis default example along with other are made available in the shiny package’s installed folder:\n\n# get path to \"examples\" under your installation of the Shiny R package\ndir_examples  &lt;- system.file(\"examples\", package=\"shiny\")\n\n# get all directories listed there\ndirs_examples &lt;- list.dirs(dir_examples, recursive = F)\n\n# show the folder name only, not the rest of the path preceding (ie dirname())\nbasename(dirs_examples)\n\n [1] \"01_hello\"      \"02_text\"       \"03_reactivity\" \"04_mpg\"       \n [5] \"05_sliders\"    \"06_tabsets\"    \"07_widgets\"    \"08_html\"      \n [9] \"09_upload\"     \"10_download\"   \"11_timer\"     \n\n\nAnother way to launch the shiny app is with the following:\n\n# set directory to 01_hello app, aka the simplest default faithful app\ndir_app &lt;- file.path(dir_examples, \"01_hello\")\n\n\n# run the app\nshiny::runApp(dir_app)\n\n\n\n\n\n\n\nWhat happens as you change the display.mode?\n\n\n\nLookup help for the argument display.mode in the runApp() function (enter ?runApp in R Console).\n\nWhat is the default mode for this app?\nHow is that defined?\nWhat’s an alternative display.mode value to apply?\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nThe default mode is “showcase”, which shows you the code and highlights in yellow the code that gets executed as the user interacts with the inputs.\nThis is defined by the DESCRIPTION file in the same folder:\n\n\nfile.path(dir_app, \"DESCRIPTION\") |&gt; readLines()\n\n[1] \"Title: Hello Shiny!\"                \"Author: RStudio, Inc.\"             \n[3] \"AuthorUrl: http://www.rstudio.com/\" \"License: MIT\"                      \n[5] \"DisplayMode: Showcase\"              \"Tags: getting-started\"             \n[7] \"Type: Shiny\"                       \n\n\n\nThe other mode is “normal”:\n\n\nshiny::runApp(dir_app, display.mode = \"normal\")"
  },
  {
    "objectID": "shiny.html#create-a-complex-shiny-app",
    "href": "shiny.html#create-a-complex-shiny-app",
    "title": "3  Interactive: Shiny apps",
    "section": "3.3 Create a complex Shiny app",
    "text": "3.3 Create a complex Shiny app\nIn this next more complicated app we’ll create an interactive time series plot and map. Users can select a station from a drop-down menu and see the time series for any of the available indicators from another drop-down selection. The map will show the location of the selected station.\n\n\n\nComplex app to create using water quality data from Tampa Bay, FL.\n\n\nHere is the full set of expandable code for the app:\n\n\nShow Code: app.R\n# Goal: Create an app to show a time series by station and indicator.\n#  Also show map of stations and selected station.\n\n# global.R ----\n\n# * load libraries ----\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(leaflet)\nlibrary(plotly)\nif (!\"tbeptools\" %in% rownames(installed.packages()))\n  install.packages(\n    \"tbeptools\",\n    repos = c(\n      tbeptech = \"https://tbep-tech.r-universe.dev\",\n      CRAN     = \"https://cloud.r-project.org\") )\nlibrary(tbeptools)\nlibrary(tidyr)\n\n# * prep data ----\nd &lt;- epcdata |&gt;\n  select(\n    station                 = epchc_station,\n    SampleTime,\n    lat                     = Latitude,\n    lon                     = Longitude,\n    `Total Nitrogen (mg/L)` = tn,\n    `Chlorophyll-a (ug/L)`  = chla,\n    `Secchi depth (m)`      = sd_m) |&gt;\n  pivot_longer(\n    names_to  = \"indicator\",\n    values_to = \"value\",\n    `Total Nitrogen (mg/L)`:`Secchi depth (m)`)\n\n# * data for select ----\nstations   &lt;- unique(d$station)\nindicators &lt;- unique(d$indicator)\nlocations  &lt;- d |&gt;\n  select(station, lon, lat) |&gt;\n  unique()\n\n#  ui.R ----\nui &lt;- fluidPage(\n  wellPanel(\n    h2(\"Water Quality\"),\n    selectInput(\"sel_sta\", \"Station\",   choices = stations),\n    selectInput(\"sel_ind\", \"Indicator\", choices = indicators),\n    plotlyOutput(\"tsplot\"),\n    leafletOutput(\"map\") )\n)\n\n#  server.R ----\nserver &lt;- function(input, output, session) {\n\n  # * get_data(): reactive to inputs ----\n  get_data &lt;- reactive({\n    d |&gt;\n      filter(\n        station   == input$sel_sta,\n        indicator == input$sel_ind)\n  })\n\n  # * tsplot: time series plot ----\n  output$tsplot &lt;- renderPlotly({\n   g &lt;- ggplot(\n      get_data(),\n      aes(\n        x = SampleTime,\n        y = value) ) +\n      geom_line() +\n      labs(y = input$sel_ind)\n    ggplotly(g)\n  })\n\n  # * map ----\n  output$map &lt;- renderLeaflet({\n\n    # filter locations by station\n    locs_sta &lt;- locations |&gt;\n      filter(\n        station == input$sel_sta)\n\n    # create map\n    leaflet(locations) |&gt;\n      addProviderTiles(providers$CartoDB.Positron) |&gt;\n      # add all stations\n      addLabelOnlyMarkers(\n        lat          = ~lat,\n        lng          = ~lon,\n        label        = ~as.character(station),\n        labelOptions = labelOptions(\n          noHide   = T,\n          textOnly = T) ) |&gt;\n      # add selected station\n      addCircles(\n        data   = locs_sta,\n        lng    = ~lon,\n        lat    = ~lat,\n        color  = \"red\",\n        weight = 20)\n  })\n}\n\n# run ----\nshinyApp(ui, server)\n\n\nYou might notice the extra four dashes at the end of some of the comments in the code. Adding comments like these allows you to easily navigate to that section of code from the lower-left of the Source pane in RStudio:\n\n\n\nWhen comments end with four or more dashes ---- in the code, RStudio includes it as a menu item in the lower left of the Source pane to quickly jump to that section in the code. In this case menus are used to indicate content in app.R that might otherwise be split into seperate files: global.R, ui.R and server.R. Then an asterisk prefix * is used to bullet key sections within.\n\n\nIn this extended tutorial, we will delve deeper into reactivity, data wrangling with dplyr, and the advantages of using R libraries that wrap JavaScript functionality. We’ll start from the default Shiny application using the Old Faithful Geyser data and transform it into a more complex application.\n\n3.3.1 Prepare data\nFirst, let’s prepare the water quality data for our app from the Tampa Bay Estuary Program R package tbeptools that we’ll install if it’s not already installed on your computer.\n\nif (!\"tbeptools\" %in% rownames(installed.packages()))\n  install.packages(\n    \"tbeptools\",\n    repos = c(\n      tbeptech = \"https://tbep-tech.r-universe.dev\",\n      CRAN     = \"https://cloud.r-project.org\") )\nlibrary(tbeptools)\n\nepcdata\n\n# A tibble: 27,601 × 26\n   bay_segment epchc_station SampleTime             yr    mo Latitude Longitude\n   &lt;chr&gt;               &lt;dbl&gt; &lt;dttm&gt;              &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n 1 HB                      6 2023-04-17 10:00:00  2023     4     27.9     -82.5\n 2 HB                      7 2023-04-17 10:15:00  2023     4     27.9     -82.5\n 3 HB                      8 2023-04-17 13:35:00  2023     4     27.9     -82.4\n 4 MTB                     9 2023-04-17 12:14:00  2023     4     27.8     -82.4\n 5 MTB                    11 2023-04-17 10:29:00  2023     4     27.8     -82.5\n 6 MTB                    13 2023-04-17 10:43:00  2023     4     27.8     -82.5\n 7 MTB                    14 2023-04-17 11:33:00  2023     4     27.8     -82.5\n 8 MTB                    16 2023-04-26 09:22:00  2023     4     27.7     -82.5\n 9 MTB                    19 2023-04-26 09:33:00  2023     4     27.7     -82.6\n10 LTB                    23 2023-04-26 11:43:00  2023     4     27.7     -82.6\n# ℹ 27,591 more rows\n# ℹ 19 more variables: Total_Depth_m &lt;dbl&gt;, Sample_Depth_m &lt;dbl&gt;, tn &lt;dbl&gt;,\n#   tn_q &lt;chr&gt;, sd_m &lt;dbl&gt;, sd_raw_m &lt;dbl&gt;, sd_q &lt;chr&gt;, chla &lt;dbl&gt;,\n#   chla_q &lt;chr&gt;, Sal_Top_ppth &lt;dbl&gt;, Sal_Mid_ppth &lt;dbl&gt;,\n#   Sal_Bottom_ppth &lt;dbl&gt;, Temp_Water_Top_degC &lt;dbl&gt;,\n#   Temp_Water_Mid_degC &lt;dbl&gt;, Temp_Water_Bottom_degC &lt;dbl&gt;,\n#   `Turbidity_JTU-NTU` &lt;chr&gt;, Turbidity_Q &lt;chr&gt;, Color_345_F45_PCU &lt;chr&gt;, …\n\n\nThe dataset epcdata (?epcdata for details) is “lazily loaded” as part of the tbeptools R package, available once the package is loaded with library(tbeptools), similar to how faithful (?faithful for details) is automatically available from the base R package datasets.\n\n\n\n\n\n\nHow should we tidy epcdata?\n\n\n\n\nWhat are the 3 goals of tidy data, per tidyr.tidyverse.org?\nLet’s assume we want three indicators: Total Nitrogen (mg/L) (tn), Chlorophyll-a (ug/L) (chla), and Secchi depth (m) (sd_m). Based on tidy principles, we want each row to capture a unique “observation” and any co-varying “variables” (such as location and time). So, do we need to pivot longer (?tidyr::pivot_longer) or wider (?tidyr::pivot_longer) to get each row as its own observation?\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\nThe 3 goals of tidy data are:\n\nEvery column is a variable.\nEvery row is an observation.\nEvery cell is a single value.\n\nThe epcdata is currently in wide format, with each variable as its own column. We want to pivot it longer so that each row is an observation of a single indicator.\n\n\n\n\n\n\nThe dplyr package is the ‘swiss army knife’ (or ‘plyers’) for data wrangling, along with its close cousin tidyr. Let’s look at some basic operations: filtering, selecting, and pivoting.\n\nFilter\nReduce rows based on condition(s) that evaluate logically (i.e. True or False)\nd |&gt; \n  dplyr::filter(station == 8)\nSelect\nReduce columns to only those specified\nd |&gt; \n  dplyr::select(\n    station = epchc_station, \n    SampleTime,\n    lon     = Longitude,\n    lat     = Latitude)\nPivot\nTransform the data from wide to long format, or vice versa\nd |&gt; \n  tidyr::pivot_longer(\n    names_to  = \"var\", \n    values_to = \"val\")\n\nApplying the above concepts, we get:\n\n# * load libraries ----\nlibrary(dplyr)\nlibrary(tbeptools)\nlibrary(tidyr)\n\n# * prep data ----\nd &lt;- epcdata |&gt;\n  select(\n    station                 = epchc_station,\n    SampleTime,\n    lat                     = Latitude,\n    lon                     = Longitude,\n    `Total Nitrogen (mg/L)` = tn,\n    `Chlorophyll-a (ug/L)`  = chla,\n    `Secchi depth (m)`      = sd_m) |&gt;\n  pivot_longer(\n    names_to  = \"indicator\",\n    values_to = \"value\",\n    `Total Nitrogen (mg/L)`:`Secchi depth (m)`)\nd\n\n# A tibble: 82,803 × 6\n   station SampleTime            lat   lon indicator               value\n     &lt;dbl&gt; &lt;dttm&gt;              &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                   &lt;dbl&gt;\n 1       6 2023-04-17 10:00:00  27.9 -82.5 Total Nitrogen (mg/L)   0.235\n 2       6 2023-04-17 10:00:00  27.9 -82.5 Chlorophyll-a (ug/L)    1.5  \n 3       6 2023-04-17 10:00:00  27.9 -82.5 Secchi depth (m)      NaN    \n 4       7 2023-04-17 10:15:00  27.9 -82.5 Total Nitrogen (mg/L)   0.284\n 5       7 2023-04-17 10:15:00  27.9 -82.5 Chlorophyll-a (ug/L)    2.1  \n 6       7 2023-04-17 10:15:00  27.9 -82.5 Secchi depth (m)        1.4  \n 7       8 2023-04-17 13:35:00  27.9 -82.4 Total Nitrogen (mg/L)   0.246\n 8       8 2023-04-17 13:35:00  27.9 -82.4 Chlorophyll-a (ug/L)    3.2  \n 9       8 2023-04-17 13:35:00  27.9 -82.4 Secchi depth (m)      NaN    \n10       9 2023-04-17 12:14:00  27.8 -82.4 Total Nitrogen (mg/L)   0.183\n# ℹ 82,793 more rows\n\n\nWe additionally need to prepare data for the following elements:\n\nStations\nList of unique station numbers for selecting from a drop-down menu.\nIndicators\nList of unique indicators for selecting from a drop-down menu.\nLocations\nList of unique station locations (i.e. stations with lat/lon coordinates) to display on the map.\n\n\n# * data for select ----\nstations   &lt;- unique(d$station)\nindicators &lt;- unique(d$indicator)\nlocations  &lt;- d |&gt;\n  select(station, lon, lat) |&gt;\n  unique()\n\nstations\n\n [1]  6  7  8  9 11 13 14 16 19 23 24 25 28 32 33 36 38 40 41 44 46 47 50 51 52\n[26] 55 60 63 64 65 66 67 68 70 71 73 80 81 82 84 90 91 92 93 95\n\nindicators\n\n[1] \"Total Nitrogen (mg/L)\" \"Chlorophyll-a (ug/L)\"  \"Secchi depth (m)\"     \n\nlocations\n\n# A tibble: 45 × 3\n   station   lon   lat\n     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1       6 -82.5  27.9\n 2       7 -82.5  27.9\n 3       8 -82.4  27.9\n 4       9 -82.4  27.8\n 5      11 -82.5  27.8\n 6      13 -82.5  27.8\n 7      14 -82.5  27.8\n 8      16 -82.5  27.7\n 9      19 -82.6  27.7\n10      23 -82.6  27.7\n# ℹ 35 more rows\n\n\n\n\n3.3.2 Add User Interface\nLet’s add dropdown menus for station and indicator selection and placeholders for plotly and leaflet outputs. These outputs are htmlwidgets  you learned about in the morning (see Quarto using htmlwidgets), except we will be updating them interactively based on user input.\n#  ui.R ----\nui &lt;- fluidPage(\n\n  # * layout ----\n  wellPanel(\n    h2(\"Water Quality\"),\n    \n    # * input widgets ----\n    selectInput(\"sel_sta\", \"Station\",   choices = stations),\n    selectInput(\"sel_ind\", \"Indicator\", choices = indicators),\n    \n    # * output htmlwidgets ----\n    plotlyOutput(\"tsplot\"),\n    leafletOutput(\"map\") )\n)\n\n3.3.2.1 Layout\nNotice that shiny::fluidPage() and shiny::wellPanel() are used to setup the layout of the app. For more details, check out Shiny - Application layout guide. And for even more advanced layout options, checkout shinydashboard and bslib R packages.\n\n\n\n\n\n\nHow does this layout compare with the first app?\n\n\n\n\n\n\n\n\n3.3.2.2 Input Widgets\nNotice that shiny::selectInput() is used to setup the dropdown menus.\n\n\n\n\n\n\nWhat are the arguments used by shiny::selectInput()?\n\n\n\n\n\n\n\n\n\n\n\n\nWhat other input widgets might you use?\n\n\n\nCheck out the Shiny - Widget Gallery.\n\n\n\n\n3.3.2.3 Htmlwidget outputs\nNotice that plotly::plotlyOutput() and leaflet::leafletOutput() are used to layout the htmlwidgets  you learned about in the morning (see Quarto using htmlwidgets), except we will be updating them interactively based on user input with server-side functions.\n\n\n\n3.3.3 Add Server Functions\nThe htmlwidget R packages made for Shiny generally have two functions: 1) an *Output to place in the layout (ui.R); and 2) a render* function amongst the back-side functions (server.R) based on user inputs:\n\ngeneral form: render* (server.R) -&gt; *Output (ui.R)\nplotly: renderPlotly() -&gt; plotlyOutput()\nleaflet: leafletOutput() -&gt; renderLeaflet()\n\n\n3.3.3.1 Render time series plot\nLet’s add a renderPlotly() function to update the time series plot based on user inputs. The renderPlotly() function takes a plotly interactive plot object. We can use the plotly::ggplotly() function to take a static ggplot2 plot object and make it an interactive plotly object. Using ggplot2 allows us to take advantage of the Grammar of Graphics principles to render plots using a layered approach (see cheatsheet, summary or book).\nThe get_data() function allows us to generate a data frame reactive to user inputs and available for use across multiple server-side functions (although here we only use one). For more, see Shiny - Use reactive expressions.\n#  server.R ----\nserver &lt;- function(input, output, session) {\n\n  # * get_data(): reactive to inputs ----\n  get_data &lt;- reactive({\n    d |&gt;\n      filter(\n        station   == input$sel_sta,\n        indicator == input$sel_ind)\n  })\n\n  # * tsplot: time series plot ----\n  output$tsplot &lt;- renderPlotly({\n    g &lt;- ggplot(\n      get_data(),\n      aes(\n        x = SampleTime,\n        y = value) ) +\n      geom_line() +\n      labs(y = input$sel_ind)\n    ggplotly(g)\n  })\n}\n\n\n3.3.3.2 Render map\nLet’s add a renderLeaflet() function to update the map based on user inputs. The renderLeaflet() function takes a leaflet interactive map object. We can use the leaflet::addLabelOnlyMarkers function to add station labels. And to highlight the selected station we can use leaflet::addCircles().\n  # * map ----\n  output$map &lt;- renderLeaflet({\n\n    # filter locations by station\n    locs_sta &lt;- locations |&gt;\n      filter(\n        station == input$sel_sta)\n\n    # create map\n    leaflet(locations) |&gt;\n      addProviderTiles(providers$CartoDB.Positron) |&gt;\n      # add all stations\n      addLabelOnlyMarkers(\n        lat          = ~lat,\n        lng          = ~lon,\n        label        = ~as.character(station),\n        labelOptions = labelOptions(\n          noHide   = T,\n          textOnly = T) ) |&gt;\n      # add selected station\n      addCircles(\n        data   = locs_sta,\n        lng    = ~lon,\n        lat    = ~lat,\n        color  = \"red\",\n        weight = 20)\n  })"
  },
  {
    "objectID": "shiny.html#publish-app",
    "href": "shiny.html#publish-app",
    "title": "3  Interactive: Shiny apps",
    "section": "3.4 Publish App",
    "text": "3.4 Publish App\nOf the options to Share your Shiny apps, the easiest is using ShinyApps.io, which makes a publicly accessible web page for your app for up to 5 apps for free (see Pricing for details). Visit Shiny - Getting started with shinyapps.io to run through the following sequence:\n\nInstall the rsconnect R package.\nCreate an account at ShinyApps.io.\nConfigure rsconnect with token in RStudio.\nPublish the app from RStudio."
  },
  {
    "objectID": "shiny.html#further-resources",
    "href": "shiny.html#further-resources",
    "title": "3  Interactive: Shiny apps",
    "section": "Further Resources",
    "text": "Further Resources\n\nShiny Cheatsheet\nShiny Tutorial\nMastering Shiny book"
  },
  {
    "objectID": "ui_design.html#definitions",
    "href": "ui_design.html#definitions",
    "title": "4  Co-designing",
    "section": "4.1 Definitions:",
    "text": "4.1 Definitions:\n\nco-design : Designing with equal contribution from stakeholders at every step of development\nuser story : As a ___ I want ___ so that ___.\nuse case : Generalized summary of user stories in context of the application.\niterative design : Repeating pattern of 1) design next iteration 2) user evaluation\nminimum viable product : First design iteration with minimal features to be useful.\nspeak aloud protocol : Method for user evaluation that aims to minimize evaluator impact."
  },
  {
    "objectID": "ui_design.html#references",
    "href": "ui_design.html#references",
    "title": "4  Co-designing",
    "section": "4.2 References:",
    "text": "4.2 References:\n\nR Graph Gallery - useful for choosing data visualizations\n“Building on a human-centred, iterative, and agile co-design strategy to facilitate the availability of deep ocean data”\nMore on the Think Aloud Protocol from Nielsen Norman Group"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Benthic Data\n\n\n\nTampa Bay\n\n\nflexdashboard\n\n\n\nA benthic data dashboard for Tampa Bay\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFL Water Quality Dash\n\n\n\nWater Quality\n\n\nTime Series\n\n\nflexdashboard\n\n\n\nDashboard for displaying basic water quality data in Florida.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLand Use Data\n\n\n\nTampa Bay\n\n\n\nA land use change dashboard for Tampa Bay\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNMS Climate Dashboard\n\n\n\nMBON\n\n\nClimate Change\n\n\nTime Series\n\n\n\nNOAA NMS Climate Dashboard\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNekton Data\n\n\n\nTampa Bay\n\n\nflexdashboard\n\n\n\nA nekton data dashboard for Tampa Bay\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOBIS Indicators\n\n\n\nMBON\n\n\nBiodiversity\n\n\nSpatial Mapping\n\n\n\nA library for mapping biodiversity using OBIS data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPiney Point Data\n\n\n\nTampa Bay\n\n\n\nA Piney Point dashboard for Tampa Bay\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRocky Intertidal Dashboard\n\n\n\nBiodiversity\n\n\nSpatial Mapping\n\n\nflexdashboard\n\n\n\nMBON Pole to Pole Biodiversity Dashboard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nScallop Data\n\n\n\nTampa Bay\n\n\n\nA scallop dashboard for Tampa Bay\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSeagrass Data\n\n\n\nTampa Bay\n\n\nflexdashboard\n\n\n\nA seagrass transect dashboard for Tampa Bay\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSeascapes for Sanctuaries\n\n\n\nMBON\n\n\nWater Quality\n\n\nTime Series\n\n\nSpatial Mapping\n\n\n\nSeascapes over time and space for US Sanctuaries\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTidal Creek Data\n\n\n\nTampa Bay\n\n\nflexdashboard\n\n\n\nA tidal creek dashboard for Tampa Bay\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUseful Links\n\n\nAdditional resources for continued learning\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWater Quality\n\n\n\nTampa Bay\n\n\nWater Quality\n\n\nflexdashboard\n\n\n\nA water quality dashboard for Tampa Bay\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "resources/useful.html#quarto",
    "href": "resources/useful.html#quarto",
    "title": "Useful Links",
    "section": "Quarto",
    "text": "Quarto\n\nOfficial Quarto Website\nQuarto Reference Materials\nQuarto Cheatsheet\nLearning Quarto with RStudio\nOpenscapes Quarto Tutorial"
  },
  {
    "objectID": "resources/useful.html#shiny",
    "href": "resources/useful.html#shiny",
    "title": "Useful Links",
    "section": "Shiny",
    "text": "Shiny\n\nOfficial Shiny Website\nLearning Shiny with RStudio\nMastering Shiny\nShiny Cheatsheet\nEngineering Production Grade Shiny Apps"
  },
  {
    "objectID": "resources/useful.html#open-science-websites",
    "href": "resources/useful.html#open-science-websites",
    "title": "Useful Links",
    "section": "Open Science Websites",
    "text": "Open Science Websites\n\nNCEAS Open Science for Synthesis workshop\nNCEAS Reproducible Research Techniques\nOpen Science Foundation open science workshop\nOpenscapes\nOpenscapes Champions Lesson Series\nSupercharge your research: A 10 week plan for open data science\nROpenSci guidance on creating a Code of Conduct\nNOAA Reproducible Reporting with R\nPeerJ collection on practical data science"
  },
  {
    "objectID": "resources/useful.html#data-management-tools",
    "href": "resources/useful.html#data-management-tools",
    "title": "Useful Links",
    "section": "Data Management Tools",
    "text": "Data Management Tools\n\nEnvironmental Data Initiative Data Management Resources\nUniversity of California DMPTool\nUS Geological Survey resources for Metadata Creation\nELIXIR and others Data Stewardship Wizard\nTBEP Data Management SOP"
  },
  {
    "objectID": "resources/useful.html#tbep-r-trainings",
    "href": "resources/useful.html#tbep-r-trainings",
    "title": "Useful Links",
    "section": "TBEP R Trainings",
    "text": "TBEP R Trainings\n\nPeconic Estuary Program R training, recording\nTBEP June 2020 R training, recordings\nWriting functions in R\nR package development workflow\nA soft introduction to Shiny"
  },
  {
    "objectID": "resources/useful.html#r-lessons-tutorials",
    "href": "resources/useful.html#r-lessons-tutorials",
    "title": "Useful Links",
    "section": "R Lessons & Tutorials",
    "text": "R Lessons & Tutorials\n\nSoftware Carpentry: R for Reproducible Scientific Analysis\nData Carpentry: Geospatial Workshop\nData Carpentry: R for Data Analysis and Visualization of Ecological Data\nData Carpentry: Data Organization in Spreadsheets\nR for Water Resources Data Science\nRStudio Webinars, many topics\nR For Cats: Basic introduction site, with cats!\nTopical cheatsheets from RStudio, also viewed from the help menu\nCheatsheet from CRAN of base R functions\nTotally awesome R-related artwork by Allison Horst\nColor reference PDF with text names, Color cheatsheet PDF from NCEAS"
  },
  {
    "objectID": "resources/useful.html#r-ebookscourses",
    "href": "resources/useful.html#r-ebookscourses",
    "title": "Useful Links",
    "section": "R eBooks/Courses",
    "text": "R eBooks/Courses\n\nJenny Bryan’s Stat545.com\nGarrett Grolemund and Hadley Wickham’s R For Data Science\nChester Ismay and Albert Y. Kim’s Modern DiveR\nJulia Silge and David Robinson Text Mining with R\nHadley Wickham’s Advanced R\nHadley Wickham’s R for Data Science\nYihui Xie R Markdown: The Definitive Guide\nWinston Chang R Graphics Cookbook\nWegman et al. Remote Sensing and GIS for Ecologists: Using Open Source Software\nLovelace et al. Geocomputation with R\nEdszer Pebesma and Roger Bivand Spatial Data Science"
  },
  {
    "objectID": "resources/useful.html#gitgithub",
    "href": "resources/useful.html#gitgithub",
    "title": "Useful Links",
    "section": "Git/Github",
    "text": "Git/Github\n\nJenny Bryan’s Happy Git and Github for the useR\nGit and GitHub for the Casual User\nCoding Club Intro to Github"
  },
  {
    "objectID": "resources/tbepwq.html#background",
    "href": "resources/tbepwq.html#background",
    "title": "Water Quality",
    "section": "Background",
    "text": "Background\nThe water quality dashboard provides an in-depth view of water quality conditions in Tampa Bay, including a report card to assess annual trends by major bay segments. Additional features include an assessment of seasonal trends, site-level trends, and data downloads."
  },
  {
    "objectID": "resources/tbepwq.html#dashboard",
    "href": "resources/tbepwq.html#dashboard",
    "title": "Water Quality",
    "section": "Dashboard",
    "text": "Dashboard\nView the dashboard by visiting https://shiny.tbep.org/wq-dash"
  },
  {
    "objectID": "resources/tbepsg.html#background",
    "href": "resources/tbepsg.html#background",
    "title": "Seagrass Data",
    "section": "Background",
    "text": "Background\nThe seagrass transect dashboard can be used to view results for the annual transect monitoring program in Tampa Bay. Data are available from the mid-1990s to present day. The dashboard provides summary information, results for individual transects, estimates of the seagrass edge, and data downloads."
  },
  {
    "objectID": "resources/tbepsg.html#dashboard",
    "href": "resources/tbepsg.html#dashboard",
    "title": "Seagrass Data",
    "section": "Dashboard",
    "text": "Dashboard\nView the dashboard by visiting https://shiny.tbep.org/seagrasstransect-dash"
  },
  {
    "objectID": "resources/tbepbt.html#background",
    "href": "resources/tbepbt.html#background",
    "title": "Benthic Data",
    "section": "Background",
    "text": "Background\nThe benthic dashboard provides information on the biological health of the benthic communities in Tampa Bay and information on sediment contaminants. The benthic data are summarized using the Tampa Bay Benthic Index. Sediment data can be viewed for over 100 contaminants, including summary plots as PEL ratios."
  },
  {
    "objectID": "resources/tbepbt.html#dashboard",
    "href": "resources/tbepbt.html#dashboard",
    "title": "Benthic Data",
    "section": "Dashboard",
    "text": "Dashboard\nView the dashboard by visiting https://shiny.tbep.org/benthic-dash"
  },
  {
    "objectID": "resources/tbeptc.html#background",
    "href": "resources/tbeptc.html#background",
    "title": "Tidal Creek Data",
    "section": "Background",
    "text": "Background\nTidal creeks or tributaries are essential habitats in the Tampa Bay estuary and serve as important focal points for understanding watershed inputs that affect water quality. This dashboard provides an interface to view and download results for all tidal creeks in the identified population of over 300 creeks in southwest Florida. A summary report card, individual creek indicators, and data downloads are available."
  },
  {
    "objectID": "resources/tbeptc.html#dashboard",
    "href": "resources/tbeptc.html#dashboard",
    "title": "Tidal Creek Data",
    "section": "Dashboard",
    "text": "Dashboard\nView the dashboard by visiting https://shiny.tbep.org/tidalcreek-dash"
  },
  {
    "objectID": "resources/tbepnk.html#background",
    "href": "resources/tbepnk.html#background",
    "title": "Nekton Data",
    "section": "Background",
    "text": "Background\nNekton data describe fish and other swimming organisms that inhabitat an estuary. The Tampa Bay Nekton Index describes the condition of the nekton community as a single score from 0 - 100. The dashboard provides information on index scores by major bay segments and results for individual sample stations. Data downloads are also available."
  },
  {
    "objectID": "resources/tbepnk.html#dashboard",
    "href": "resources/tbepnk.html#dashboard",
    "title": "Nekton Data",
    "section": "Dashboard",
    "text": "Dashboard\nView the dashboard by visiting https://shiny.tbep.org/nekton-dash"
  },
  {
    "objectID": "resources/tbeplu.html#background",
    "href": "resources/tbeplu.html#background",
    "title": "Land Use Data",
    "section": "Background",
    "text": "Background\nUpland, coastal, and subtidal habitats have changed dramatically in Tampa Bay and its watershed over the last several decades. This dashboard provides an overview of how these habitats have changed over time. Summaries are provided in simple tables and as change analysis plots that show shifts between habitat types. Data downloads are also available."
  },
  {
    "objectID": "resources/tbeplu.html#dashboard",
    "href": "resources/tbeplu.html#dashboard",
    "title": "Land Use Data",
    "section": "Dashboard",
    "text": "Dashboard\nView the dashboard by visiting https://shiny.tbep.org/landuse-change"
  },
  {
    "objectID": "resources/tbeppp.html#background",
    "href": "resources/tbeppp.html#background",
    "title": "Piney Point Data",
    "section": "Background",
    "text": "Background\nPiney Point is a former fertilizer processing facility on the southeast shore of Tampa Bay. In March 2021, 215 million gallons of nutrient-rich wastewater from Piney Point were discharged to Tampa Bay. This dashboard provides a summary of the response-based monitoring data collected in 2021 to assess the effects of this large nutrient influx on the bay’s resources."
  },
  {
    "objectID": "resources/tbeppp.html#dashboard",
    "href": "resources/tbeppp.html#dashboard",
    "title": "Piney Point Data",
    "section": "Dashboard",
    "text": "Dashboard\nView the dashboard by visiting https://shiny.tbep.org/piney-point"
  },
  {
    "objectID": "resources/tbepsc.html#background",
    "href": "resources/tbepsc.html#background",
    "title": "Scallop Data",
    "section": "Background",
    "text": "Background\nThe Scallop Data dashboard provides a summary of participatory science efforts to monitor the scallop population in Tampa Bay. The dashboard is dynamic and created using RMarkdown (Quarto predecessor). It does not include any server components as required by interactive Shiny dashboards."
  },
  {
    "objectID": "resources/tbepsc.html#dashboard",
    "href": "resources/tbepsc.html#dashboard",
    "title": "Scallop Data",
    "section": "Dashboard",
    "text": "Dashboard\nView the dashboard by visiting https://tbep-tech.github.io/scallop-search/"
  },
  {
    "objectID": "resources/fl_wq_dash.html#background",
    "href": "resources/fl_wq_dash.html#background",
    "title": "FL Water Quality Dash",
    "section": "Background",
    "text": "Background\nData and decision support tools for assessing water quality in Florida."
  },
  {
    "objectID": "resources/fl_wq_dash.html#docs",
    "href": "resources/fl_wq_dash.html#docs",
    "title": "FL Water Quality Dash",
    "section": "Docs",
    "text": "Docs\nView the dashboard at 7yl4r.shinyapps.io/wq-dash\n\n\n\nscreenshot"
  },
  {
    "objectID": "resources/nms_climate_dash.html#background",
    "href": "resources/nms_climate_dash.html#background",
    "title": "NMS Climate Dashboard",
    "section": "Background",
    "text": "Background\nDashboard of climate indicators across NOAA National Marine Sanctuaries."
  },
  {
    "objectID": "resources/nms_climate_dash.html#docs",
    "href": "resources/nms_climate_dash.html#docs",
    "title": "NMS Climate Dashboard",
    "section": "Docs",
    "text": "Docs\nView the docs at noaa-onms.github.io/climate-dashboard/\n\n\n\nscreenshot"
  },
  {
    "objectID": "resources/obisindicators.html#background",
    "href": "resources/obisindicators.html#background",
    "title": "OBIS Indicators",
    "section": "Background",
    "text": "Background\nR package for generating indicators from OBIS"
  },
  {
    "objectID": "resources/obisindicators.html#docs",
    "href": "resources/obisindicators.html#docs",
    "title": "OBIS Indicators",
    "section": "Docs",
    "text": "Docs\nView the docs at marinebon.github.io/obisindicators/\n\n\n\nexample_es50_map"
  },
  {
    "objectID": "resources/rocky_shore_dash.html#background",
    "href": "resources/rocky_shore_dash.html#background",
    "title": "Rocky Intertidal Dashboard",
    "section": "Background",
    "text": "Background\nData visualization dashboard of biodiversity monitoring observations from rocky intertidal habitats."
  },
  {
    "objectID": "resources/rocky_shore_dash.html#docs",
    "href": "resources/rocky_shore_dash.html#docs",
    "title": "Rocky Intertidal Dashboard",
    "section": "Docs",
    "text": "Docs\nView the dashboard in this Github repository\n\n\n\nscreenshot"
  },
  {
    "objectID": "resources/seascapes.html#background",
    "href": "resources/seascapes.html#background",
    "title": "Seascapes for Sanctuaries",
    "section": "Background",
    "text": "Background\nSeascapes are a dynamic sea water classification product derived from satellite imagery by Maria Kavanaugh et al.\nThe source code of the Shiny app makes use of custom data wrangling functions in the R package seascapeR and the following htmlwidgets for interactive visualization:\n\nmap: leaflet\ntime series: dygraphs"
  },
  {
    "objectID": "resources/seascapes.html#docs",
    "href": "resources/seascapes.html#docs",
    "title": "Seascapes for Sanctuaries",
    "section": "Docs",
    "text": "Docs\nView the dashboard at shiny.marinebon.app/seascapes.\n\nThe different Seascape Classes are based on a combination of variables derived from clustering."
  },
  {
    "objectID": "setup.html#install-r-and-rstudio",
    "href": "setup.html#install-r-and-rstudio",
    "title": "Appendix A — Setup for the workshop",
    "section": "A.1 Install R and RStudio",
    "text": "A.1 Install R and RStudio\nR and RStudio are separate downloads and installations. R is the underlying statistical computing software. RStudio is a graphical integrated development environment (IDE) that makes using R much easier and more interactive. You need to install R before you install RStudio.\nThanks to the USGS-R Training group and Data Carpentry for making their installation materials available. The following instructions come directly from their materials, with a few minor edits to help you get set up.\n\nA.1.1 Windows: Download and install R\nGo to CRAN and download the R installer for Windows. Make sure to choose the latest stable version (v4.2.3 as of April 2023).\nOnce the installer downloads, Right-click on it and select “Run as administrator”.\nType in your credentials and click yes (or if you don’t have administrator access have your IT rep install with Admin privileges).\n\n\n\n\n\nYou can click next through the standard dialogs and accept most defaults. But at the destination screen, please verify that it is installing it to C:\\Program Files\\R\n\n\n\n\n\nAt the “Select Components” screen, you can accept the default and install both 32-bit and 64-bit versions.\n\n\n\n\n\nAt this screen, uncheck ‘Create a desktop icon’ because non-admin users in Windows will be unable to delete it.\n\n\n\n\n\n\n\nA.1.2 Windows: Download and install RStudio\nDownload RStudio from here.\nAfter download, double-click the installer. It will ask for your administrator credentials to install (you might need to have your IT rep install again).\nAccept all the default options for the RStudio install.\n\n\n\n\n\n\n\nA.1.3 macOS: Download and install R\n\nDownload and install R from the CRAN website for Mac here.\nSelect the .pkg file for the latest R version\nDouble click on the downloaded file to install R\nIt is also a good idea to install XQuartz (needed by some packages)\n\n\n\nA.1.4 macOS: Download and install RStudio\n\nGo to the RStudio download page\nUnder Installers select the appropriate RStudio download file for macOS\nDouble click the file to install RStudio\n\n\n\nA.1.5 Check Install\nOnce installed, RStudio should be accessible from the start menu. Start up RStudio. Once running it should look something like this:"
  },
  {
    "objectID": "setup.html#sec-instquarto",
    "href": "setup.html#sec-instquarto",
    "title": "Appendix A — Setup for the workshop",
    "section": "A.2 Install Quarto",
    "text": "A.2 Install Quarto\nA visual editor for Quarto is installed with RStudio. However, you’ll need to install Quarto CLI to make full use of its features.\nNavigate to https://quarto.org/docs/get-started/. You’ll see a screen that looks like this:\n\n\n\n\n\nSelect the download appropriate for your operating system (Windows is the big blue button). After the file is downloaded, navigate to the folder containing the file, double-click to install, and accept the default settings at the prompts.\nAfter installation is done, open RStudio (or close and open again) and select the Terminal tab. This tab is located on the bottom-left pane, next to the Console tab. Type quarto check at the prompt and press enter. You should see something like this if installation was successful."
  },
  {
    "objectID": "setup.html#sec-setgit",
    "href": "setup.html#sec-setgit",
    "title": "Appendix A — Setup for the workshop",
    "section": "A.3 Create GitHub account",
    "text": "A.3 Create GitHub account\nOpen a web browser and enter the url https://github.com. On the top-right, you should see a button to sign up. Click the button and register an account by choosing an email, username, and password."
  },
  {
    "objectID": "setup.html#sec-instgit",
    "href": "setup.html#sec-instgit",
    "title": "Appendix A — Setup for the workshop",
    "section": "A.4 Install Git (optional)",
    "text": "A.4 Install Git (optional)\nAfter you’ve registered a new GitHub account, you can install the Git software on your computer. Git is version control software used by RStudio that allows you to access GitHub. Open the url https://git-scm.com/book/en/v2/Getting-Started-Installing-Git and follow the instructions for your operating system.\nAfter Git is installed, open RStudio (or close and open again) to verify the installation. You should see a new “Git” tab located in the top-right pane of RStudio.\n\n\n\n\n\n\nA.4.1 Make sure RStudio can talk to GitHub via Git\nThe next step can be a bit tricky, but is essential if you want to access your GitHub using RStudio and Git. First, install the usethis R package in RStudio.\n\ninstall.packages(\"usethis\")\n\nYou must let Git know who you are and that you have permission to write to a GitHub repository. First, let Git know who you are, where you enter your user name and email associated with the account from the previous step.\n\nusethis::use_git_config(user.name=\"Jane Doe\", user.email=\"jane@example.org\")\n\nNext, you need to setup a personal access token (PAT) that defines the permissions to write to a repository. This can be done as follows:\n\nusethis::create_github_token()\n\nThen follow the remaining prompts to complete the PAT creation. A more thorough explanation can be found here."
  },
  {
    "objectID": "setup.html#sec-setshi",
    "href": "setup.html#sec-setshi",
    "title": "Appendix A — Setup for the workshop",
    "section": "A.5 Setup shinyapps.io",
    "text": "A.5 Setup shinyapps.io\nThe shinyapps.io website is a service provided by Posit for hosting Shiny applications online. A free option is available, with additional paid tiers depending on your needs. Although there are other free options, this website is the easiest and quickest way to host a Shiny application.\nFirst, navigate to shinyapps.io and click the “Sign Up” button. After you’ve setup your GitHub account, you can sign up for shinyapps.io by selecting the GitHub sign up option.\n\n\n\n\n\nNext, install the rsconnect package in R. This package lets you connect to shinyapps.io and push applications from your local computer.\n\ninstall.packages(\"rsconnect\")\n\nYou need to obtain an access token from shinyapps.io to configure the rsconnect package to use your account. In your shinyapps.io dashboard, click your user name on the top right and select Tokens.\n\n\n\n\n\nAdd a new token, copy/paste the command to setup your account info, and execute it in the R console. It will look something like this and there will a button that allows you to copy the command to your clipboard, where &lt;TOKEN&gt; and &lt;SECRET&gt; are specific to your account and should not be shared.\n\nrsconnect::setAccountInfo(name='beckmw',\n              token='&lt;TOKEN&gt;',\n              secret='&lt;SECRET&gt;')\n\nNow you will be able to push a Shiny application to your shinyapps.io account as follows.\n\nlibrary(rsconnect)\ndeployApp()\n\nMore info can be found here."
  },
  {
    "objectID": "setup.html#sec-cloud",
    "href": "setup.html#sec-cloud",
    "title": "Appendix A — Setup for the workshop",
    "section": "A.6 Posit Cloud (optional)",
    "text": "A.6 Posit Cloud (optional)\nPosit Cloud provides an environment to use RStudio and the resources above through a web browser. We’ve created a workspace on Posit Cloud that includes most of the content described above. Open the following URL in a web browser: https://posit.cloud/content/5544370\nYou will see a login screen that looks like this:\n\n\n\n\n\nSign up using a personal login or existing account (Google, GitHub, etc.).\nYou’ll see the workspace in your browser once you’ve signed in. You’ll need to make a permanent copy to save your work. Just click the button at the top marked “+ Save as Permanent Copy”. When this is done, the red text at the top indicating “TEMPORARY COPY” will no longer be visible.\n\n\n\n\n\nNow you can follow along with the workshop content."
  },
  {
    "objectID": "rintro.html#rstudio",
    "href": "rintro.html#rstudio",
    "title": "Appendix B — Introduction to R",
    "section": "B.1 RStudio",
    "text": "B.1 RStudio\nRStudio is the go-to Interactive Development Environment (IDE) for R. Rstudio includes many features to improve the user’s experience.\nLet’s get familiar with RStudio.\n\nB.1.1 Open R and RStudio\nFind the RStudio shortcut on your computer and fire it up. You should see something like this:\n\n\n\n\n\nThere are four panes in RStudio:\n\nSource: Your primary window for writing code to send to the console, this is where you write and save R “scripts”\nConsole: This is where code is executed in R\nEnvironment, History, etc.: A tabbed window showing your working environment, code execution history, and other useful things\nFiles, plots, etc.: A tabbed window showing a file explorer, a plot window, list of installed packages, help files, and viewer\n\n\n\nB.1.2 Scripting\nIn most cases, you will not enter and execute code directly in the console. Code can be written in a script and then sent directly to the console.\nOpen a new script from the File menu…\n\n\n\n\n\n\n\nB.1.3 Executing code in RStudio\nAfter you write code in an R script, it can be sent to the Console to run the code. There are two ways to do this. First, you can hit the Run button at the top right of the scripting window. Second, you can use ctrl+enter (cmd+enter on a Mac). Either option will run the line(s) of script that are selected."
  },
  {
    "objectID": "rintro.html#r-language-fundamentals",
    "href": "rintro.html#r-language-fundamentals",
    "title": "Appendix B — Introduction to R",
    "section": "B.2 R language fundamentals",
    "text": "B.2 R language fundamentals\nR is built around functions. The basic syntax of a function follows the form: function_name(arg1, arg2, ...).\nWith the base install, you will gain access to many functions (2344, to be exact). Some examples:\n\n# print\nprint(\"hello world!\")\n\n[1] \"hello world!\"\n\n# sequence\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n# random numbers\nrnorm(100, mean = 10, sd = 2)\n\n  [1]  8.128561  8.261048  6.447694 11.822728 11.768642  8.230854 11.100494\n  [8]  9.988191 13.936196 10.264868  8.513528 11.565359 11.468325 12.277680\n [15] 10.395277  7.735068  7.527188  7.897253 10.872726 14.233246 12.842406\n [22] 11.324001  7.876831 13.837726 11.550338  8.290777 10.815908 12.057958\n [29] 11.523292  6.982781  9.945666  9.802633  7.433354  9.839746  9.779492\n [36]  8.949391  9.094280  6.531044 13.052510  6.023231 11.448344  9.494504\n [43] 13.240137 15.807913 13.387937 10.069601  6.168293  8.920284  8.238622\n [50] 11.518087 11.510082 13.014612  7.356151 10.674882 11.229237 11.743190\n [57]  9.096469 11.757561  9.298889  8.229381 12.003020  9.199877  7.577620\n [64]  8.164159 12.751527  8.438016  9.900038 13.380532  8.056403 12.353621\n [71] 11.104041 13.048930 10.485342  9.183230  9.496198  9.698261 11.592084\n [78] 12.328648 12.808133 11.634411  8.556371 10.159334 10.299923 10.996449\n [85] 13.004204 11.959609 11.182110 10.389620  8.123433 12.867985  9.228226\n [92]  9.685829  8.653685 13.554147  4.353677  9.272952 15.990078 10.872886\n [99] 10.969372  9.184371\n\n# average \nmean(rnorm(100))\n\n[1] 0.1841985\n\n# sum\nsum(rnorm(100))\n\n[1] 34.14379\n\n\nVery often you will see functions used like this:\n\nmy_random_sum &lt;- sum(rnorm(100))\n\nThe first part of the line is the name of an object that you make up. The second bit, &lt;-, is the assignment operator. This tells R to take the result of sum(rnorm(100)) and store it in an object named, my_random_sum. It is stored in the environment and can be used by just executing it’s name in the console.\n\nmy_random_sum\n\n[1] 12.59487\n\n\n\nB.2.1 What is the environment?\nThere are two outcomes when you run code. First, the code will simply print output directly in the console. Second, there is no output because you have stored it as a variable using &lt;-. Output that is stored is saved in the environment. The environment is the collection of named objects that are stored in memory for your current R session."
  },
  {
    "objectID": "rintro.html#packages",
    "href": "rintro.html#packages",
    "title": "Appendix B — Introduction to R",
    "section": "B.3 Packages",
    "text": "B.3 Packages\nThe base installation of R is quite powerful. Packages allow you to include new methods for use in R.\n\nB.3.1 CRAN\nMany packages are available on CRAN, The Comprehensive R Archive Network. This is where you download R and also where most will gain access to packages. As of 2023-11-07, there are 19959 packages on CRAN!\n\n\nB.3.2 Installing packages\nWhen a package gets installed, that means the source code is downloaded and put into your library. A default library location is set for you.\nWe use the install.packages() function to download and install a package. Here, we install the readxl package, used below, which is used to upload data from and Excel file.\n\ninstall.packages(\"readxl\")\n\nYou should see some text in the R console showing progress of the installation and a prompt after installation is done.\nAfter installation, you can load a package using the library() function. This makes all functions in a package available for you to use.\n\nlibrary(readxl)\n\nAn important aspect of packages is that you only need to download them once, but every time you start RStudio you need to load them with the library() function."
  },
  {
    "objectID": "rintro.html#data-structures-in-r",
    "href": "rintro.html#data-structures-in-r",
    "title": "Appendix B — Introduction to R",
    "section": "B.4 Data structures in R",
    "text": "B.4 Data structures in R\nNow we can talk about R data structures. Simply put, a data structure is a way for programming languages to handle information storage.\n\nB.4.1 Vectors (one-dimensional data)\nThe basic data format in R is a vector - a one-dimensional grouping of elements that have the same type. These are all vectors and they are created with the c (concatenate) function:\n\ndbl_var &lt;- c(1, 2.5, 4.5)\nint_var &lt;- c(1L, 6L, 10L)\nlog_var &lt;- c(TRUE, FALSE, T, F)\nchr_var &lt;- c(\"a\", \"b\", \"c\")\n\nThe four types of vectors are double (or numeric), integer, logical, and character. The following functions can return useful information about the vectors:\n\nclass(dbl_var)\n\n[1] \"numeric\"\n\nlength(log_var)\n\n[1] 4\n\n\n\n\nB.4.2 Data frames (two-dimensional data)\nA collection of vectors represented as one data object are often described as two-dimensional data, like a spreadsheet, or in R speak, a data frame. Here’s a simple example:\n\nltrs &lt;- c(\"a\", \"b\", \"c\")\nnums &lt;- c(1, 2, 3)\nlogs &lt;- c(T, F, T)\nmydf &lt;- data.frame(ltrs, nums, logs)\nmydf\n\n  ltrs nums  logs\n1    a    1  TRUE\n2    b    2 FALSE\n3    c    3  TRUE\n\n\nThe only constraints required to make a data frame are:\n\nEach column (vector) contains the same type of data\nThe number of observations in each column is equal."
  },
  {
    "objectID": "rintro.html#getting-your-data-into-r",
    "href": "rintro.html#getting-your-data-into-r",
    "title": "Appendix B — Introduction to R",
    "section": "B.5 Getting your data into R",
    "text": "B.5 Getting your data into R\nIt is the rare case when you manually enter your data in R. Most data analysis workflows typically begin with importing a dataset from an external source. We’ll be using read_excel() function from the readxl package.\nWe can import the ExampleSites.xlsx dataset as follows. Note the use of a relative file path. You can see what R is using as your “working directory” using the getwd() function.\n\nsitdat &lt;- read_excel(\"data/ExampleSites.xlsx\")\n\nLet’s explore the dataset a bit.\n\n# get the dimensions\ndim(sitdat)\n\n[1] 11  5\n\n# get the column names\nnames(sitdat)\n\n[1] \"Monitoring Location ID\"        \"Monitoring Location Name\"     \n[3] \"Monitoring Location Latitude\"  \"Monitoring Location Longitude\"\n[5] \"Location Group\"               \n\n# see the first six rows\nhead(sitdat)\n\n# A tibble: 6 × 5\n  `Monitoring Location ID` `Monitoring Location Name` Monitoring Location Lati…¹\n  &lt;chr&gt;                    &lt;chr&gt;                                           &lt;dbl&gt;\n1 ABT-026                  Rte 2, Concord                                   42.5\n2 ABT-062                  Rte 62, Acton                                    42.4\n3 ABT-077                  Rte 27/USGS, Maynard                             42.4\n4 ABT-144                  Rte 62, Stow                                     42.4\n5 ABT-237                  Robin Hill Rd, Marlboro                          42.3\n6 ABT-301                  Rte 9, Westboro                                  42.3\n# ℹ abbreviated name: ¹​`Monitoring Location Latitude`\n# ℹ 2 more variables: `Monitoring Location Longitude` &lt;dbl&gt;,\n#   `Location Group` &lt;chr&gt;\n\n# get the overall structure\nstr(sitdat)\n\ntibble [11 × 5] (S3: tbl_df/tbl/data.frame)\n $ Monitoring Location ID       : chr [1:11] \"ABT-026\" \"ABT-062\" \"ABT-077\" \"ABT-144\" ...\n $ Monitoring Location Name     : chr [1:11] \"Rte 2, Concord\" \"Rte 62, Acton\" \"Rte 27/USGS, Maynard\" \"Rte 62, Stow\" ...\n $ Monitoring Location Latitude : num [1:11] 42.5 42.4 42.4 42.4 42.3 ...\n $ Monitoring Location Longitude: num [1:11] -71.4 -71.4 -71.4 -71.5 -71.6 ...\n $ Location Group               : chr [1:11] \"Assabet\" \"Assabet\" \"Assabet\" \"Assabet\" ...\n\n\nYou can also view a dataset in a spreadsheet style using the View() function:\n\nView(sitdat)"
  },
  {
    "objectID": "rintro.html#summary",
    "href": "rintro.html#summary",
    "title": "Appendix B — Introduction to R",
    "section": "B.6 Summary",
    "text": "B.6 Summary\nIn this intro we learned about R and Rstudio, some of the basic syntax and data structures in R, and how to import files. You’ll be able to follow the rest of the workshop with this knowledge."
  },
  {
    "objectID": "addlquarto.html#output-options",
    "href": "addlquarto.html#output-options",
    "title": "Appendix C — Additional Quarto Content",
    "section": "C.1 Output options",
    "text": "C.1 Output options\nRendering a Quarto file to an HTML, PDF, or Word document is as simple as adding the appropriate option to the YAML. This is done by choosing the format when you create a new Quarto file:\n\n\n\n\n\nThe output format can also be added in the YAML of the document.\n---\ntitle: \"Quarto practice\"\nauthor: \"Marcus Beck\"\neditor: visual\nformat: html\n---\n\n\n\n\n\n\nTip\n\n\n\nThe default output format is HTML and it does not need to be added explicitly to the YAML.\n\n\nAlternative formats are specified the same way (i.e., Word and PDF).\n---\ntitle: \"Quarto practice\"\nauthor: \"Marcus Beck\"\neditor: visual\nformat: docx\n---\n---\ntitle: \"Quarto practice\"\nauthor: \"Marcus Beck\"\neditor: visual\nformat: pdf\n---\nYou can also specify multiple formats (note the indentation). The default setting just indicates that we want to use all default options for each format and this option must be included.\n---\ntitle: \"Quarto practice\"\nauthor: \"Marcus Beck\"\neditor: visual\nformat: \n  html: default\n  docx: default\n  pdf: default\n---\nYou can use the dropdown menu to render each file format one at a time. The dropdown menu will show the options that are included in the YAML.\n\n\n\n\n\nYou can also render all formats at once using the quarto package in the console. The path to your file will differ depending on where it is in your working directory.\nquarto::quarto_render('data/quartoex.qmd')\nOr you can render all formats at once using the render command in the terminal (terminal tab, bottom left pane of RStudio). This requires the separate installation of Quarto described in the setup. This is the Quarto Command Line Interface (CLI).\n\n\nTerminal\n\nquarto render data/quartoex.qmd\n\nRendering a file to PDF uses LaTeX and you’ll need to install tinytex before you can use this option. This can also be done in the terminal.\n\n\nTerminal\n\nquarto install tool tinytex\n\nThere are several options you can include in the YAML to control the formatting of the output. Some of the options apply to all format types, whereas others are specific to a type. Here’s an example building out these options.\n---\ntitle: \"Quarto practice\"\nauthor: \"Marcus Beck\"\neditor: visual\ntoc: true \nnumber-sections: true\nformat: \n  html: \n    code-fold: true\n  docx: default\n  pdf: \n    geometry: \n      - top=30mm\n      - left=0mm\n---\nIn the above example, there are two new options that apply globally to the HTML, Word, and PDF outputs. Specifically, we’ve indicated that we’d like a table of contents (toc: true) and that the sections should be numbered (number-sections: true) in the rendered documents.\nWe’ve also added some specific options to the HTML and PDF output. For the HTML output, we’ve indicated that we want the code chunks to be folded (i.e., toggle between seen and not seen, code-fold: true). For the PDF output, we’ve changed the geometry of the margins using the geometry options.\nHere’s what the HTML output would look like:\n\n\n\n\n\nThere are many other options available for each output format, as well as other format types. View the full list here."
  },
  {
    "objectID": "addlquarto.html#citations-and-references",
    "href": "addlquarto.html#citations-and-references",
    "title": "Appendix C — Additional Quarto Content",
    "section": "C.2 Citations and References",
    "text": "C.2 Citations and References\nOne of the more valuable aspects of Quarto is the ability to easily add and reference other works in your document. This includes finding papers and reports, citing them in your document, and formatting references - all with relative ease in Quarto.\nYou can of course do this using the source editor, but it’s slightly easier using the visual editor. If we switch to visual mode (top-left button of the .qmd file), you can type a forward-slash to view a menu of items to insert in the document. Just start typing text to search items to insert.\n\n\n\n\n\n\nTip\n\n\n\nThe Insert Anything tool in the visual editor is useful to… insert anything! Just execute / at the beginning of a line or Ctrl/Cmd + / after some text.\n\n\n\n\n\n\n\nYou can also insert a citation from the menu at the top of the .qmd file.\n\n\n\n\n\nEither option will open the citation menu where you can add citations from a variety of sources (ie., Zotero, DOI, CrossRef, PubMed, or DataCite).\nFor example, we can copy/paste a DOI to find a reference of interest.\n\n\n\n\n\nOr we can search by title.\n\n\n\n\n\nOnce the paper is found, you can click the Insert button to add it to your document. This adds a reference file, information in the YAML, and the in-text citation. The reference file will be called references.bib by default and includes a BibTeX formatted reference that looks like this:\n@article{shafland1982,\n    title = {Lower lethal temperatures for fourteen non-native fishes in Florida},\n    author = {Shafland, Paul L. and Pestrak, James M.},\n    year = {1982},\n    month = {03},\n    date = {1982-03},\n    journal = {Environmental Biology of Fishes},\n    pages = {149--156},\n    volume = {7},\n    number = {2},\n    doi = {10.1007/bf00001785},\n    url = {http://dx.doi.org/10.1007/BF00001785},\n    langid = {en}\n}\nThe YAML file will now indicate the reference file to use that includes the references (bibliography: references.bib).\n---\ntitle: \"Quarto practice\"\nauthor: \"Marcus Beck\"\neditor: visual\nbibliography: references.bib\ntoc: true \nnumber-sections: true\nformat: \n  html: \n    code-fold: true\n  docx: default\n  pdf: \n    geometry: \n      - top=30mm\n      - left=0mm\n---\nThe text citation will look like this, where @ is the tag used to reference the citation using the identifier from the references file.\nMany non-native species in Florida have lower lethal temperatures [@shafland1982].\nWhen the Quarto file is rendered, the citation will be formatted and you’ll see it added to the references section at the end of the document.\n\nMany non-native species in Florida have lower lethal temperatures (shafland1982?).\n\n\n\n\n\n\nThe @ citation syntax also has different options for displaying the citation in the text (full explanation here). For example, omitting the brackets does the following:\n@shafland1982 state that many non-native species in Florida have lower lethal temperatures.\n\n(shafland1982?) state that many non-native species in Florida have lower lethal temperatures.\n\nAdditional information about citations in Quarto can be found here."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  }
]